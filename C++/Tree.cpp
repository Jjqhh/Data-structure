// 树的存储方法

// 双亲表示法（顺序表）（找双亲容易，找孩子难，适用于经常对双亲进行操作的时候）
struct PTNode
{
    char data;
    int parent; // 双亲位置域
};

#define MAX_TREE_SIZE 100
struct PTree
{
    PTNode nodes[MAX_TREE_SIZE];
    int r, n; // 根节点的位置和节点个数
};

// 孩子链表（顺序表）（找孩子容易，找双亲难）（适合找孩子）
// 孩子节点结构
struct CTNode
{
    int child;    // 孩子节点在数组中的下标（位置）
    CTNode *next; // 孩子链表
};
using ChildPtr = CTNode *;

// 双亲节点结构
struct CTBox
{
    char data;
    ChildPtr firstchild; // 孩子链表头指针
};

// 树结构
struct CTree
{
    CTBox nodes[MAX_TREE_SIZE];
    int r, n; // 节点数和根节点的位置
};

//***************更常用的表示方法******************
// 孩子兄弟表示法（二叉树表示法，二叉链表表示法）（找双亲困难）
// 用二叉链表作树的存储结构，链表中的每个节点的两个指针域分别指向其第一个孩子节点和下一个兄弟节点
struct CSNode
{
    char data;
    CSNode *firstchild, *nextsibing; // 嵌套递归定义（左孩子右兄弟）
};
using CSTree = CTNode *;

// 树与二叉树的转换（兄弟相连留长子）
// 给定一棵树，一定可以找到唯一对应的二叉树与之对应

// 将树转为二叉树
// 加线：在兄弟之间加一连线
// 抹线：对每个节点，除了其左孩子外，去除其与其余孩子之间的关系
// 旋转：以树的根节点为轴心，将整树顺时针旋转45度

// 将二叉树转为树
// 加线：若p节点是双亲节点的左孩子，则将p的右孩子，右孩子的右孩子......沿分支找到的所有的右孩子，都与p的双亲用线连起来
// 抹线：抹掉原二叉树中双亲与右孩子之间的连线
// 调整：将节点按层次排列，形成树结构

// 树与森林的遍历7

// 树的遍历（三种方式）
// 先根（次序）遍历：若树不空，先访问根节点，然后依次先根遍历各颗子树
// 后根（次序）遍历：若树不空，先依次后跟遍历各颗子树，然后访问根节点
// 层次遍历：若树不空，自上而下自左至右访问树中的每个节点

// 森林的遍历
// （将森林看作三部分构成）
// 1.森林中第一棵树个根节点
// 2.森林中第一棵树的子树森林
// 3.森林中其他树构成的森林

// 先序遍历：依次从左至右对森林中的每棵树进行先根遍历
// 中序遍历：依次从左至右对森林中的每棵树进行后根遍历
